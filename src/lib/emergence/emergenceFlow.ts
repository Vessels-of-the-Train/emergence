import { defineFlow } from "@genkit-ai/core";
import { z } from "zod";
import { EmergenceMath, EmergenceState } from "./emergenceMath";
import { HistoryEntry, ContextMatrix, EmergenceContext } from "./emergenceTypes";

const HistoryEntrySchema = z.object({
    state: z.number(),
    context: z.object({
        valence: z.number(),
        persistence: z.number(),
        grounding: z.number(),
        source: z.number(),
        clarity: z.number(),
        associations: z.number()
    }),
    genesisType: z.enum(["infusion", "collapse", "merge", "initial"]),
    timestamp: z.number(),
    label: z.string().optional(),
    description: z.string().optional()
});

export const emergenceMathFlow = (defineFlow as any)(
    {
        name: "emergenceMathFlow",
        inputSchema: z.object({
            I_vec: z.string().describe("Input vector (textual description)"),
            E_vec: z.number().describe("Emotional/Energy vector (-1 to 1)"),
            H_log: z.array(HistoryEntrySchema).describe("History log of previous states"),
            D_pot: z.number().describe("Depth potential (0 to 1)"),
            context: z.object({
                persistence: z.number().optional(),
                clarity: z.number().optional()
            }).optional(),
            secondary_vectors: z.array(z.object({
                E_vec: z.number(),
                D_pot: z.number()
            })).optional().describe("Additional vectors to merge simultaneously")
        }),
        outputSchema: z.object({
            state: z.number().describe("Resulting state (0=Potential, 1=Presence)"),
            result: z.string().describe("Protocol result label"),
            context: z.any().describe("Resulting emergence context"),
            new_entry: HistoryEntrySchema.describe("The new history entry generated by this step")
        }),
    },
    async (matrix: ContextMatrix) => {
        const { E_vec, D_pot, H_log, context: inputCtx, secondary_vectors } = matrix;
        console.log(`[GenkitFlow] Executing emergenceMathFlow with Input: E:${E_vec.toFixed(2)}, D:${D_pot.toFixed(2)}`);

        // 1. Reconstruct current state from history or initialize
        let currentState: EmergenceState;

        // TRAJECTORY ANALYSIS
        let trajectoryModifier = 1.0;
        let stabilityBonus = 0;
        
        if (H_log && H_log.length > 0) {
            const lastEntry = H_log[H_log.length - 1];
            console.log(`[GenkitFlow] Reconstructing from history: State ${lastEntry.state}`);
            currentState = new EmergenceState(
                lastEntry.state,
                lastEntry.context || {
                    valence: 0,
                    persistence: 0.1,
                    grounding: 0.2,
                    source: 0,
                    clarity: 0.5,
                    associations: 0
                },
                lastEntry.genesisType || "initial",
                lastEntry.timestamp
            );

            // Analyze last 3 steps for stability
            if (H_log.length >= 3) {
                const recent = H_log.slice(-3);
                const valenceVariance = Math.abs(recent[0].context.valence - recent[2].context.valence);
                if (valenceVariance < 0.1) {
                    console.log("[GenkitFlow] Trajectory Stable. Applying Persistence Bonus.");
                    stabilityBonus = 0.1;
                } else if (valenceVariance > 0.5) {
                    console.log("[GenkitFlow] Trajectory Volatile. Applying Damping.");
                    trajectoryModifier = 0.8;
                }
            }

        } else {
            console.log("[GenkitFlow] Initializing new emergence state (potential)");
            currentState = new EmergenceState(0, {
                valence: 0,
                persistence: 0.1,
                grounding: 0.2,
                source: 0,
                clarity: 0.5,
                associations: 0
            });
        }

        // 2. Create stimulus from input
        const stimulus: Partial<EmergenceContext> = {
            valence: E_vec,
            grounding: D_pot,
            persistence: (inputCtx?.persistence || 0.5) + stabilityBonus,
            clarity: inputCtx?.clarity || 0.5,
            source: 1.0,
            associations: 1
        };

        // 3. Transform state: If already active, check for merge/amplify, otherwise infuse
        if (currentState.value === 1) {
            console.log("[GenkitFlow] State is ACTIVE (1). Attempting Merge/Amplify.");
            const stimulusState = new EmergenceState(1, stimulus as EmergenceContext, "initial");
            const resultState = EmergenceMath.merge(currentState, stimulusState);
            
            // Apply trajectory damping if volatile
            resultState.context.valence *= trajectoryModifier;
            
            console.log(`[GenkitFlow] Merge Result: ${resultState.genesisType} (Value: ${resultState.value})`);
            currentState = resultState;
        } else {
            console.log("[GenkitFlow] State is POTENTIAL (0). Executing Infusion.");
            currentState = EmergenceMath.infuse(currentState, stimulus);
        }

        // 3b. Process Secondary Vectors (Multi-Merge)
        if (secondary_vectors && secondary_vectors.length > 0 && currentState.value === 1) {
            console.log(`[GenkitFlow] Processing ${secondary_vectors.length} secondary vectors...`);
            for (const vec of secondary_vectors) {
                 const secStimulus: Partial<EmergenceContext> = {
                    valence: vec.E_vec,
                    grounding: vec.D_pot,
                    persistence: 0.5,
                    clarity: 0.5,
                    source: 1.0,
                    associations: 1
                };
                const secState = new EmergenceState(1, secStimulus as EmergenceContext, "initial");
                // Recursive merge
                currentState = EmergenceMath.merge(currentState, secState);
                console.log(`[GenkitFlow] Secondary Merge Result: ${currentState.genesisType}`);
            }
        }

        // 4. Apply System Protocols
        let protocol = "OPTIMIZED_STATE";

        if (currentState.context.valence > 0.85) {
            protocol = "PROTECTIVE_STATE";
        } else if (currentState.context.grounding < 0.25) {
            // If grounding is too low, collapse back to potential
            if (currentState.value === 1) {
                console.log("[GenkitFlow] Critical Grounding Loss. Triggering Collapse Protocol.");
                currentState = EmergenceMath.collapse(currentState, { valence: -0.2 });
                protocol = "COLLAPSE_PROTOCOL";
            }
        } else if (currentState.context.persistence > 0.9) {
            protocol = "STABLE_EMERGENCE";
        }

        console.log(`[GenkitFlow] Flow Complete. Protocol: ${protocol}, Final Value: ${currentState.value}`);

        const newEntry: HistoryEntry = {
            state: currentState.value,
            context: currentState.context,
            genesisType: currentState.genesisType,
            timestamp: currentState.timestamp
        };

        return {
            state: currentState.value,
            result: protocol,
            context: currentState.context,
            new_entry: newEntry
        };
    }
);
